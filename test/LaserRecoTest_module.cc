////////////////////////////////////////////////////////////////////////
// Class:       LaserRecoTest
// Module Type: analyzer
// File:        LaserRecoTest_module.cc
//
// Generated at Fri Oct 28 13:49:04 2016 by matthias,,, using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "LaserObjects/LaserHits.h"

#include "LaserObjects/LaserUtils.h"

class LaserRecoTest;

class LaserRecoTest : public art::EDAnalyzer {
public:
    explicit LaserRecoTest(fhicl::ParameterSet const &p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    LaserRecoTest(LaserRecoTest const &) = delete;

    LaserRecoTest(LaserRecoTest &&) = delete;

    LaserRecoTest &operator=(LaserRecoTest const &) = delete;

    LaserRecoTest &operator=(LaserRecoTest &&) = delete;

    // Required functions.
    void analyze(art::Event const &e) override;

    void reconfigure(fhicl::ParameterSet const &pset) override;

    void beginJob() override;

    int CheckHits(art::ValidHandle<std::vector<recob::Hit>> reco_hits, std::vector<std::vector<float>> def_hits);

private:


    std::unique_ptr< std::vector<std::vector<std::vector<float> > > > RawDigitDefs; ///< line by line csv container
    std::string fHitModul, fHitLabel;
    std::string fTestConfigFile;
};


LaserRecoTest::LaserRecoTest(fhicl::ParameterSet const &pset)
        :
        EDAnalyzer(pset)  // ,
// More initializers here.
{
    this->reconfigure(pset);
}

void LaserRecoTest::analyze(art::Event const &event) {
    auto id = event.id().event();
    auto DigitTag = art::InputTag(fHitModul, fHitLabel);
    std::stringstream error_string;


    std::cout << "==> Testing Simple Single Track Reco " << id << std::endl;
    try {
        art::ValidHandle<std::vector<recob::Hit>> LaserHits = event.getValidHandle<std::vector<recob::Hit>>(DigitTag);
    }
    catch (...) {
        assert(false && "Event does not contain any hits");
    }
    art::ValidHandle<std::vector<recob::Hit>> LaserHits = event.getValidHandle<std::vector<recob::Hit>>(DigitTag);

    auto hit_def = RawDigitDefs->at(id);


    if (fTestConfigFile.compare("HitDefs-10003.txt") == 0) {
        if (id == 0) {
            // first track should not be fully found
            //assert(CheckHits(LaserHits, hit_def) != -1);
        }
        else{
            //assert(CheckHits(LaserHits, hit_def) == -1);
        }
    } else if  (fTestConfigFile.compare("HitDefs-10004.txt") == 0) {
        std::cout << " ==> Testing High Threshold cut" << std::endl;
        if (id == 0) {
            assert(CheckHits(LaserHits, hit_def) != -1);
        }
        else {
            assert(CheckHits(LaserHits, hit_def) == -1);
        }

    }
    else {
        assert(CheckHits(LaserHits, hit_def) == -1);
    }
}

void LaserRecoTest::reconfigure(fhicl::ParameterSet const &pset) {
    fHitModul = pset.get<std::string>("HitModul");
    fHitLabel = pset.get<std::string>("HitLabel");
    fTestConfigFile = pset.get<std::string>("TestConfigFile");
}

void LaserRecoTest::beginJob() {
    RawDigitDefs = lasercal::ReadHitDefs(fTestConfigFile, false);
}

int LaserRecoTest::CheckHits(art::ValidHandle<std::vector<recob::Hit>> reco_hits,
                             std::vector<std::vector<float> > hit_defs) {
    /*
     *  Checks if a hit vector and a hit definition vector are identical, if true this return -1, otherwise it returns the wire index
     *  in the hit definitions vector where the discrepancy was found.
     */

    int epsilon_tick = 5;

    // array is set to true if the defined hit was present in the reconstructed hits
    std::vector<bool> hit_checked(hit_defs.size(), false);

    // check reconstructed hits for an associate defined hit
    for (uint hit = 0; hit < reco_hits->size(); hit++) {
        int wire_reco = reco_hits->at(hit).WireID().Wire;
        int reco_peak_time = (int) reco_hits->at(hit).PeakTime();

        std::cout << "DEBUG INFO: hit ampl: " << reco_hits->at(hit).PeakAmplitude() << std::endl;

        int idx_def = -1;
        // search for the associate wire in the wire def array
        for (uint idx = 0; idx < hit_defs.size(); idx++) {
            if (hit_defs.at(idx).at(RawDigitDefinition::Wire) == wire_reco){
                idx_def = idx;
            }
        }
        if (idx_def == -1){
            std::cout << "No def hit could be found for the reconstructed hit: w: " << wire_reco << " pt " << reco_peak_time << std::endl;
            return wire_reco;
        }

        int def_peak_time = (int) hit_defs.at(idx_def).at(RawDigitDefinition::CenterTick);

        if ((def_peak_time - epsilon_tick) < reco_peak_time && reco_peak_time < (def_peak_time + epsilon_tick)) {
            hit_checked.at(idx_def) = true;
        }
        else {
            std::cout << "Hits were off at wire: " << hit << ", times were (reco/def): "
                      << reco_peak_time << " / " << def_peak_time << std::endl;

            return wire_reco;
        }
    }

    // have all defined hits been found?
    for (auto hit_check = hit_checked.begin(); hit_check != hit_checked.end(); ++hit_check) {
        auto wire = std::distance(hit_checked.begin(), hit_check);

        if (*hit_check != true){
            std::cout << "Not all hits found! missed hit at wire " << wire << std::endl;
            return wire;
        }
    }


    return -1;
}

DEFINE_ART_MODULE(LaserRecoTest)
